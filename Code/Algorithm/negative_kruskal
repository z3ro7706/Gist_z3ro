import sys
input = sys.stdin.readline

positive_table = 10**18
negative_table = -10**18

class Graph:
    def __init__(self, v):
        self.v = v
        self.edge = []
        self.parent = list(range(v+1))

    def add(self, a, b, w):
        self.edge.append((w, a, b))

    def find(self, v):
        if self.parent[v] == v:
            return v
        self.parent[v] = self.find(self.parent[v])
        return self.parent[v]

    def union(self, a, b):
        p1 = self.find(a)
        p2 = self.find(b)
        if p1 < p2:
            self.parent[p2] = p1
        else:
            self.parent[p1] = p2

    def bellman_ford(self, start):
        n = self.v
        dist = [positive_table] * (n + 1)
        dist[start] = 0

        i = 0
        while i < n - 1:
            updated = False
            for w, a, b in self.edge:
                if dist[a] == positive_table:
                    continue
                new_val = dist[a] + w
                if dist[b] > new_val:
                    dist[b] = new_val
                    updated = True
            if not updated:
                break
            i += 1

        j = 0
        while j < n:
            for w, a, b in self.edge:
                if dist[a] == positive_table:
                    continue
                new_val = dist[a] + w
                if dist[b] > new_val:
                    dist[b] = negative_table
                if dist[a] == negative_table:
                    dist[b] = negative_table
            j += 1

        return dist


n, m = map(int, input().split())
g = Graph(n)

for _ in range(m):
    a, b, w = map(int, input().split())
    g.add(a, b, w)

s = int(input())
dist = g.bellman_ford(s)

for i in range(1, n + 1):
    if dist[i] == positive_table:
        print("INF")
    elif dist[i] == negative_table:
        print("-INF")
    else:
        print(dist[i])
